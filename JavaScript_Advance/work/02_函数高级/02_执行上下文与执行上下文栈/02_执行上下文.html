<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>02_执行上下文</title>
</head>
<body>
    
    1. 代码分类（位置）
        全局代码
        函数(局部)代码
    
    2. 全局执行上下文
        在执行全局代码前将window确定为全局执行上下文
        对全局数据进行预处理
            var定义的全局变量 ==> undefined，添加为window属性
            function声明的全局函数 ==> 赋值(fun)，添加为window的方法
            this ==> 赋值(window)
        开始执行全局代码

    3. 函数执行上下文
        在调用函数，准备执行函数体之前，创建对应的函数执行上下文对象(虚拟的，存在于栈中)
        对局部数据进行预处理
            形参变量 ==> 赋值(实参) ==> 添加为执行上下文的属性
            arguments ==> 赋值(实参列表)，添加为执行上下文的属性
            var定义的局部变量 ==> undefined，添加为执行上下文的属性
            function声明的函数 ==> 赋值(fun)，添加为执行上下文的方法
            this ==> 赋值(调用函数的对象)
        开始执行函数体代码


<script>

    // --- 全局执行上下文
    console.log(a1, window.a1);
    console.log(a2);
    window.a2();
    console.log(this);
    // 此时，哪怕代码位置在声明 变量或方法之前，都能够访问到 a1, a2, this
    // 说明，在执行全局代码之前，浏览器要做一些准备工作
    // 而且，这些变量方法都在window里面，a1 和 window.a1 基本上是相同的(为什么说基本上，而不是完全相同，是因为还是有一点点的差异，后面再讲，现在讲容易搞混)

    // 这里的准备工作，就是上面 第二点：全局执行上下文 中的 三步


    var a1 = 3;     // 这里还是可以打断点的(和之前写的有出入)， var a1; 这样就不能打断点
    function a2() {};   // 这行代码也不能打断点，因为已经执行过了

    
    
    // --- 函数执行上下文

    function fn (a1) {
        console.log(a1);    // 2
        console.log(a2);    // undefined
        a3();               // a3()
        console.log(this);  // window
        console.log(arguments); // 类数组(伪数组) [2, 3]



        var a2 = 3;
        function a3() {
            console.log('a3()');
        }
    }

    fn(2, 3);
    // 函数 fn开始执行的时候，就去 函数执行上下文对象 中查找那些对应的属性
    // 重点： 函数执行上下文对象 不是一个真实的对象，而是一个虚拟对象
    // 这个对象是一片区域：里面有我们的形参，局部变量，arguments ...
    // 前面说过，局部变量放在 栈里面
    // 因此，函数执行上下文对象 就存在于栈中
    // 每次调用一个函数，都在栈中开辟一块区域(用来存放局部变量)
    // 函数调用完后，再释放这片空间
    // 虚拟的原因：1. 对象都是放在堆里面的，而这个 函数执行上下文对象 是放在栈里面的
    //            2. 这片封闭的区域，只有函数内部可见，外部是不可见的，无法访问
    //            3. 函数执行完，才能继续执行外部的代码，而当函数执行完毕后，这片空间已经释放了，里面什么都没有了
    //            (内存空间是隔离的，如果不隔离，外面一个 a， 里面一个 a，就会出问题)


    // 讲到这里，函数提升和变量提升，就已经很明白了
    // 其实就是预处理的操作

    // 执行上下文调用的时候才产生，定义的时候不产生
    // 因此函数声明时，不产生函数执行上下文，调用的时候才会有
</script>
</body>
</html>